!function(){function t(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);e&&(o=o.filter(function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable})),r.push.apply(r,o)}return r}function e(e){for(var o=1;o<arguments.length;o++){var n=null!=arguments[o]?arguments[o]:{};o%2?t(Object(n),!0).forEach(function(t){r(e,t,n[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):t(Object(n)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))})}return e}function r(t,e,r){return(e=function(t){var e=function(t,e){if("object"!=typeof t||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var o=r.call(t,e||"default");if("object"!=typeof o)return o;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(t)}(t,"string");return"symbol"==typeof e?e:e+""}(e))in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}System.register(["./index-legacy-DXqvcAAE.js","./misc-nodes-legacy-g2QYpRkX.js"],function(t,r){"use strict";var o,n,i,s,u,c,a,l,d,g;return{setters:[t=>{o=t.S,n=t.d,i=t.C,s=t.aK,u=t.q,c=t.L,a=t.F,l=t.t,d=t.p},t=>{g=t.s}],execute:function(){const r=[o.ShmetroBasic2020,o.LondonTubeBasic,o.ShanghaiSuburbanRailway,o.OsakaMetro],b=t("h",(t,o,i)=>{const s=t.getNodeAttribute(o,"type"),u=structuredClone(t.getNodeAttribute(o,s).names);for(let e=0;e<Math.abs(g[i].defaultAttrs.names.length-u.length);e++)g[i].defaultAttrs.names.length>u.length?u.push("Stn"):u.pop();const c=e(e({},g[i].defaultAttrs),{},{names:u});Object.values(r).includes(s)&&Object.values(r).includes(i)||(c.nameOffsetX=t.getNodeAttribute(o,s).nameOffsetX,c.nameOffsetY=t.getNodeAttribute(o,s).nameOffsetY),n.has(i)&&n.has(s)&&(c.color=structuredClone(t.getNodeAttribute(o,s).color)),t.removeNodeAttribute(o,s),t.mergeNodeAttributes(o,{type:i,[i]:c})}),f=(t("d",(t,e,r,o)=>o.filter(r=>"any"===e||t.getNodeAttribute(r,"type")===e).forEach(e=>{b(t,e,r)})),t("f",(t,e,r,o)=>{const n=t.getEdgeAttribute(e,"type"),i=t.getEdgeAttribute(e,"style");if(s[i].metadata.supportLinePathType.includes(r)){const i=structuredClone(u[r].defaultAttrs);let s=-1;if(o&&r!==c.Simple){const[o,n]=t.extremities(e),u=i.startFrom;s=a(t,r,o,n,u)}t.setEdgeAttribute(e,"parallelIndex",s),t.removeEdgeAttribute(e,n),t.mergeEdgeAttributes(e,{type:r,[r]:i})}})),y=(t("j",(t,e,r,o,n)=>o.filter(r=>"any"===e||t.getEdgeAttribute(r,"type")===e).forEach(e=>{f(t,e,r,n)})),t("g",(t,e,r,o)=>{const i=t.getEdgeAttribute(e,"type"),u=t.getEdgeAttribute(e,"style");if(s[r].metadata.supportLinePathType.includes(i)){const i=t.getEdgeAttribute(e,"zIndex"),c=t.getEdgeAttribute(e,u);t.removeEdgeAttribute(e,u);const a=structuredClone(s[r].defaultAttrs);n.has(u)&&n.has(r)?a.color=c.color:n.has(r)&&o&&(a.color=o),t.mergeEdgeAttributes(e,{style:r,[r]:a}),r===l.River?t.setEdgeAttribute(e,"zIndex",-5):t.setEdgeAttribute(e,"zIndex",null!=i?i:0)}})),p=(t("i",(t,e,r,o,n)=>n.filter(r=>"any"===e||t.getEdgeAttribute(r,"style")===e).forEach(e=>{y(t,e,r,o)})),t("k",(t,e,r,o)=>o.filter(e=>n.has(t.getEdgeAttribute(e,"style"))).forEach(o=>{const n=t.getEdgeAttributes(o),i=n[n.style].color;("any"===e||i[0]==e[0]&&i[1]==e[1]&&i[2]==e[2]&&i[3]==e[3])&&t.mergeEdgeAttributes(o,{[n.style]:{color:r}})})),t("c",(t,e,r,o,n)=>{[...o,...n].forEach(o=>{const n=t.getNodeAttributes(o).type,i=t.getNodeAttribute(o,n);if(void 0!==i.color)if(n!==d.Master){const t=i.color;("any"===e||t[0]==e[0]&&t[1]==e[1]&&t[2]==e[2]&&t[3]==e[3])&&(i.color=r)}else{const t=i.color.value;("any"===e||void 0===t||t[0]==e[0]&&t[1]==e[1]&&t[2]==e[2]&&t[3]==e[3])&&(i.color.value=r)}t.mergeNodeAttributes(o,{[n]:i})})})),A=(t("l",(t,e,r,o,n)=>{[...e,...r].forEach(e=>{t.setNodeAttribute(e,"zIndex",n)}),o.forEach(e=>{t.setEdgeAttribute(e,"zIndex",n)})}),(t,e,r)=>{const n=t.getNodeAttribute(e,"type"),i=(s=n).endsWith("-int")&&"basic"===r?s.replace(/-int$/,"-basic"):s.endsWith("-basic")&&"int"===r?s.replace(/-basic$/,"-int"):void 0;var s;if(i&&Object.values(o).includes(i))return i}),h=(t,e)=>{const r=t.directedEdges(e),o=new Set,s=[],u=t=>t[0]!==i.Other?t[0].toString()+"/"+t[1].toString():t[2].toString()+"/"+t[3].toString();for(const i of r){const e=t.getEdgeAttributes(i).style;if(!n.has(e))continue;const r=t.getEdgeAttributes(i)[e].color;o.has(u(r))||(o.add(u(r)),s.push(r))}return{lineColorStr:o,lineColor:s}},m=t("a",(t,e)=>{const{lineColorStr:r,lineColor:o}=h(t,e);if(r.size>1){const r=A(t,e,"int");if(r)return b(t,e,r),!0}else if(1===r.size){const r=A(t,e,"basic");if(r)return b(t,e,r),p(t,"any",o[0],[e],[]),!0}return!1}),E=t("b",(t,e)=>{var r,o;if(!((t,e)=>{const r=t.getNodeAttribute(e,"type"),o=t.getNodeAttribute(e,r);return!(!o||!("transfer"in o))})(t,e))return!1;const{lineColorStr:n,lineColor:s}=h(t,e),u=t.getNodeAttribute(e,"type"),c=t=>t[0]!==i.Other?t[0].toString()+"/"+t[1].toString():t[2].toString()+"/"+t[3].toString(),a=null!==(r=null===(o=t.getNodeAttribute(e,u).transfer)||void 0===o?void 0:o.at(0))&&void 0!==r?r:[];const l=[...a.filter(t=>n.has(c(t))),...s.filter(t=>!a.find(e=>c(t)===c(e))).map(t=>[t[0],t[1],t[2],t[3],"",""])];return JSON.stringify(a)!==JSON.stringify(l)&&(((t,e,r,o)=>{const n=t.getNodeAttribute(e,r);n&&(n.transfer=[o],t.mergeNodeAttributes(e,{[r]:n}))})(t,e,u,l),!0)});t("e",(t,e)=>{m(t,e),E(t,e)})}}})}();
