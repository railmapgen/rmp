!function(){function t(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);e&&(o=o.filter(function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable})),r.push.apply(r,o)}return r}function e(e){for(var o=1;o<arguments.length;o++){var n=null!=arguments[o]?arguments[o]:{};o%2?t(Object(n),!0).forEach(function(t){r(e,t,n[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):t(Object(n)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))})}return e}function r(t,e,r){return(e=function(t){var e=function(t,e){if("object"!=typeof t||!t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var o=r.call(t,e||"default");if("object"!=typeof o)return o;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(t)}(t,"string");return"symbol"==typeof e?e:e+""}(e))in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}System.register(["./index-legacy-C0H1G5aZ.js","./master-manager-legacy-k9uoP_1P.js"],function(t,r){"use strict";var o,n,i,s,c,u,a,l;return{setters:[t=>{o=t.d,n=t.S,i=t.aQ,s=t.q,c=t.L,u=t.o,a=t.p},t=>{l=t.s}],execute:function(){const r=[n.ShmetroBasic2020,n.LondonTubeBasic,n.ShanghaiSuburbanRailway,n.OsakaMetro],d=t("d",(t,n,i)=>{const s=t.getNodeAttribute(n,"type"),c=structuredClone(t.getNodeAttribute(n,s).names);for(let e=0;e<Math.abs(l[i].defaultAttrs.names.length-c.length);e++)l[i].defaultAttrs.names.length>c.length?c.push("Stn"):c.pop();const u=e(e({},l[i].defaultAttrs),{},{names:c});Object.values(r).includes(s)&&Object.values(r).includes(i)||(u.nameOffsetX=t.getNodeAttribute(n,s).nameOffsetX,u.nameOffsetY=t.getNodeAttribute(n,s).nameOffsetY),o.has(i)&&o.has(s)&&(u.color=structuredClone(t.getNodeAttribute(n,s).color)),t.removeNodeAttribute(n,s),t.mergeNodeAttributes(n,{type:i,[i]:u})}),g=(t("e",(t,e,r,o)=>o.filter(r=>"any"===e||t.getNodeAttribute(r,"type")===e).forEach(e=>{d(t,e,r)})),t("a",(t,e,r,o)=>{const n=t.getEdgeAttribute(e,"type"),a=t.getEdgeAttribute(e,"style");if(i[a].metadata.supportLinePathType.includes(r)){const i=structuredClone(s[r].defaultAttrs);let a=-1;if(o&&r!==c.Simple){const[o,n]=t.extremities(e),s=i.startFrom;a=u(t,r,o,n,s)}t.setEdgeAttribute(e,"parallelIndex",a),t.removeEdgeAttribute(e,n),t.mergeEdgeAttributes(e,{type:r,[r]:i})}})),b=(t("g",(t,e,r,o,n)=>o.filter(r=>"any"===e||t.getEdgeAttribute(r,"type")===e).forEach(e=>{g(t,e,r,n)})),t("b",(t,e,r,n)=>{const s=t.getEdgeAttribute(e,"type"),c=t.getEdgeAttribute(e,"style");if(i[r].metadata.supportLinePathType.includes(s)){const s=t.getEdgeAttribute(e,"zIndex"),u=t.getEdgeAttribute(e,c);t.removeEdgeAttribute(e,c);const l=structuredClone(i[r].defaultAttrs);o.has(c)&&o.has(r)?l.color=u.color:o.has(r)&&n&&(l.color=n),t.mergeEdgeAttributes(e,{style:r,[r]:l}),r===a.River?t.setEdgeAttribute(e,"zIndex",-5):t.setEdgeAttribute(e,"zIndex",null!=s?s:0)}})),f=(t("f",(t,e,r,o,n)=>n.filter(r=>"any"===e||t.getEdgeAttribute(r,"style")===e).forEach(e=>{b(t,e,r,o)})),t("h",(t,e,r,n)=>n.filter(e=>o.has(t.getEdgeAttribute(e,"style"))).forEach(o=>{const n=t.getEdgeAttributes(o),i=n[n.style].color;("any"===e||i[0]==e[0]&&i[1]==e[1]&&i[2]==e[2]&&i[3]==e[3])&&t.mergeEdgeAttributes(o,{[n.style]:{color:r}})})),t("i",(t,e,r,o,n)=>{[...o,...n].forEach(o=>{const n=t.getNodeAttributes(o).type,i=t.getNodeAttribute(o,n);if(void 0!==i.color){const t=i.color;("any"===e||t[0]==e[0]&&t[1]==e[1]&&t[2]==e[2]&&t[3]==e[3])&&(i.color=r)}t.mergeNodeAttributes(o,{[n]:i})})})),y=(t("j",(t,e,r,o,n)=>{[...e,...r].forEach(e=>{t.setNodeAttribute(e,"zIndex",n)}),o.forEach(e=>{t.setEdgeAttribute(e,"zIndex",n)})}),(t,e,r)=>{const o=t.getNodeAttribute(e,"type"),i=(s=o).endsWith("-int")&&"basic"===r?s.replace(/-int$/,"-basic"):s.endsWith("-basic")&&"int"===r?s.replace(/-basic$/,"-int"):void 0;var s;if(i&&Object.values(n).includes(i))return i});t("c",(t,e)=>{const r=t.directedEdges(e),n=new Set,i=[];for(const s of r){const e=t.getEdgeAttributes(s).style;if(!o.has(e))continue;const r=t.getEdgeAttributes(s)[e].color;n.has(r.toString())||(n.add(r.toString()),i.push(r))}if(n.size>1){const r=y(t,e,"int");r&&d(t,e,r)}else if(1===n.size){const r=y(t,e,"basic");r&&(d(t,e,r),f(t,"any",i[0],[e],[]))}})}}})}();
