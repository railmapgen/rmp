import{d as u,C as m,S as d,aQ as l,q as I,L as N,o as h,p as S}from"./index-2gKpSq6Z.js";import{s as f}from"./master-manager-BgvbGGve.js";const A=[d.ShmetroBasic2020,d.LondonTubeBasic,d.ShanghaiSuburbanRailway,d.OsakaMetro],b=(t,e,o)=>{const a=t.getNodeAttribute(e,"type"),i=structuredClone(t.getNodeAttribute(e,a).names);for(let n=0;n<Math.abs(f[o].defaultAttrs.names.length-i.length);n++)f[o].defaultAttrs.names.length>i.length?i.push("Stn"):i.pop();const s={...f[o].defaultAttrs,names:i};(!Object.values(A).includes(a)||!Object.values(A).includes(o))&&(s.nameOffsetX=t.getNodeAttribute(e,a).nameOffsetX,s.nameOffsetY=t.getNodeAttribute(e,a).nameOffsetY),u.has(o)&&u.has(a)&&(s.color=structuredClone(t.getNodeAttribute(e,a).color)),t.removeNodeAttribute(e,a),t.mergeNodeAttributes(e,{type:o,[o]:s})},C=(t,e,o,a)=>a.filter(i=>e==="any"||t.getNodeAttribute(i,"type")===e).forEach(i=>{b(t,i,o)}),v=(t,e,o,a)=>{const i=t.getEdgeAttribute(e,"type"),s=t.getEdgeAttribute(e,"style");if(l[s].metadata.supportLinePathType.includes(o)){const n=structuredClone(I[o].defaultAttrs);let r=-1;if(a&&o!==N.Simple){const[c,E]=t.extremities(e),y=n.startFrom;r=h(t,o,c,E,y)}t.setEdgeAttribute(e,"parallelIndex",r),t.removeEdgeAttribute(e,i),t.mergeEdgeAttributes(e,{type:o,[o]:n})}},j=(t,e,o,a,i)=>a.filter(s=>e==="any"||t.getEdgeAttribute(s,"type")===e).forEach(s=>{v(t,s,o,i)}),x=(t,e,o,a)=>{const i=t.getEdgeAttribute(e,"type"),s=t.getEdgeAttribute(e,"style");if(l[o].metadata.supportLinePathType.includes(i)){const n=t.getEdgeAttribute(e,"zIndex"),r=t.getEdgeAttribute(e,s);t.removeEdgeAttribute(e,s);const c=structuredClone(l[o].defaultAttrs);u.has(s)&&u.has(o)?c.color=r.color:u.has(o)&&a&&(c.color=a),t.mergeEdgeAttributes(e,{style:o,[o]:c}),o===S.River?t.setEdgeAttribute(e,"zIndex",-5):t.setEdgeAttribute(e,"zIndex",n!=null?n:0)}},k=(t,e,o,a,i)=>i.filter(s=>e==="any"||t.getEdgeAttribute(s,"style")===e).forEach(s=>{x(t,s,o,a)}),P=(t,e,o,a)=>a.filter(i=>u.has(t.getEdgeAttribute(i,"style"))).forEach(i=>{const s=t.getEdgeAttributes(i),n=s[s.style].color;(e==="any"||n[0]==e[0]&&n[1]==e[1]&&n[2]==e[2]&&n[3]==e[3])&&t.mergeEdgeAttributes(i,{[s.style]:{color:o}})}),O=(t,e,o,a,i)=>{[...a,...i].forEach(s=>{const n=t.getNodeAttributes(s).type,r=t.getNodeAttribute(s,n);if(r.color!==void 0){const c=r.color;(e==="any"||c[0]==e[0]&&c[1]==e[1]&&c[2]==e[2]&&c[3]==e[3])&&(r.color=o)}t.mergeNodeAttributes(s,{[n]:r})})},T=(t,e,o,a,i)=>{[...e,...o].forEach(s=>{t.setNodeAttribute(s,"zIndex",i)}),a.forEach(s=>{t.setEdgeAttribute(s,"zIndex",i)})},g=(t,e,o)=>{const a=n=>{if(n.endsWith("-int")&&o==="basic")return n.replace(/-int$/,"-basic");if(n.endsWith("-basic")&&o==="int")return n.replace(/-basic$/,"-int")},i=t.getNodeAttribute(e,"type"),s=a(i);if(s&&Object.values(d).includes(s))return s},W=(t,e)=>{const o=t.directedEdges(e),a=new Set,i=[],s=n=>n[0]!==m.Other?n[0].toString()+"/"+n[1].toString():n[2].toString()+"/"+n[3].toString();for(const n of o){const r=t.getEdgeAttributes(n).style;if(!u.has(r))continue;const c=t.getEdgeAttributes(n)[r].color;a.has(s(c))||(a.add(s(c)),i.push(c))}if(a.size>1){const n=g(t,e,"int");n&&b(t,e,n)}else if(a.size===1){const n=g(t,e,"basic");n&&(b(t,e,n),O(t,"any",i[0],[e],[]))}};export{v as a,x as b,W as c,b as d,C as e,k as f,j as g,P as h,O as i,T as j};
