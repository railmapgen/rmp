import{d as r,S as d,aQ as l,q as y,L as I,o as N,p as h}from"./index-Ba5L_S9o.js";import{s as f}from"./master-manager-o09fLaRl.js";const A=[d.ShmetroBasic2020,d.LondonTubeBasic,d.ShanghaiSuburbanRailway,d.OsakaMetro],b=(t,e,o)=>{const i=t.getNodeAttribute(e,"type"),n=structuredClone(t.getNodeAttribute(e,i).names);for(let a=0;a<Math.abs(f[o].defaultAttrs.names.length-n.length);a++)f[o].defaultAttrs.names.length>n.length?n.push("Stn"):n.pop();const s={...f[o].defaultAttrs,names:n};(!Object.values(A).includes(i)||!Object.values(A).includes(o))&&(s.nameOffsetX=t.getNodeAttribute(e,i).nameOffsetX,s.nameOffsetY=t.getNodeAttribute(e,i).nameOffsetY),r.has(o)&&r.has(i)&&(s.color=structuredClone(t.getNodeAttribute(e,i).color)),t.removeNodeAttribute(e,i),t.mergeNodeAttributes(e,{type:o,[o]:s})},z=(t,e,o,i)=>i.filter(n=>e==="any"||t.getNodeAttribute(n,"type")===e).forEach(n=>{b(t,n,o)}),v=(t,e,o,i)=>{const n=t.getEdgeAttribute(e,"type"),s=t.getEdgeAttribute(e,"style");if(l[s].metadata.supportLinePathType.includes(o)){const a=structuredClone(y[o].defaultAttrs);let c=-1;if(i&&o!==I.Simple){const[u,m]=t.extremities(e),E=a.startFrom;c=N(t,o,u,m,E)}t.setEdgeAttribute(e,"parallelIndex",c),t.removeEdgeAttribute(e,n),t.mergeEdgeAttributes(e,{type:o,[o]:a})}},j=(t,e,o,i,n)=>i.filter(s=>e==="any"||t.getEdgeAttribute(s,"type")===e).forEach(s=>{v(t,s,o,n)}),x=(t,e,o,i)=>{const n=t.getEdgeAttribute(e,"type"),s=t.getEdgeAttribute(e,"style");if(l[o].metadata.supportLinePathType.includes(n)){const a=t.getEdgeAttribute(e,"zIndex"),c=t.getEdgeAttribute(e,s);t.removeEdgeAttribute(e,s);const u=structuredClone(l[o].defaultAttrs);r.has(s)&&r.has(o)?u.color=c.color:r.has(o)&&i&&(u.color=i),t.mergeEdgeAttributes(e,{style:o,[o]:u}),o===h.River?t.setEdgeAttribute(e,"zIndex",-5):t.setEdgeAttribute(e,"zIndex",a!=null?a:0)}},k=(t,e,o,i,n)=>n.filter(s=>e==="any"||t.getEdgeAttribute(s,"style")===e).forEach(s=>{x(t,s,o,i)}),P=(t,e,o,i)=>i.filter(n=>r.has(t.getEdgeAttribute(n,"style"))).forEach(n=>{const s=t.getEdgeAttributes(n),a=s[s.style].color;(e==="any"||a[0]==e[0]&&a[1]==e[1]&&a[2]==e[2]&&a[3]==e[3])&&t.mergeEdgeAttributes(n,{[s.style]:{color:o}})}),O=(t,e,o,i,n)=>{[...i,...n].forEach(s=>{const a=t.getNodeAttributes(s).type,c=t.getNodeAttribute(s,a);if(c.color!==void 0){const u=c.color;(e==="any"||u[0]==e[0]&&u[1]==e[1]&&u[2]==e[2]&&u[3]==e[3])&&(c.color=o)}t.mergeNodeAttributes(s,{[a]:c})})},T=(t,e,o,i,n)=>{[...e,...o].forEach(s=>{t.setNodeAttribute(s,"zIndex",n)}),i.forEach(s=>{t.setEdgeAttribute(s,"zIndex",n)})},g=(t,e,o)=>{const i=a=>{if(a.endsWith("-int")&&o==="basic")return a.replace(/-int$/,"-basic");if(a.endsWith("-basic")&&o==="int")return a.replace(/-basic$/,"-int")},n=t.getNodeAttribute(e,"type"),s=i(n);if(s&&Object.values(d).includes(s))return s},W=(t,e)=>{const o=t.directedEdges(e),i=new Set,n=[];for(const s of o){const a=t.getEdgeAttributes(s).style;if(!r.has(a))continue;const c=t.getEdgeAttributes(s)[a].color;i.has(c.toString())||(i.add(c.toString()),n.push(c))}if(i.size>1){const s=g(t,e,"int");s&&b(t,e,s)}else if(i.size===1){const s=g(t,e,"basic");s&&(b(t,e,s),O(t,"any",n[0],[e],[]))}};export{v as a,x as b,W as c,b as d,z as e,k as f,j as g,P as h,O as i,T as j};
